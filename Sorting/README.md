## How I would choose a sorting alogithm
1. When there is no information about space constraints ==> <b><i>Quicksort</i></b><br/>
<i>Why? </i> Sorts in-place <br/>
<i>Why? </i> Runs in O(<i>nlog(n)</i>) time on average. <br/>
<i>Downsides? </i> runs in O(<i>n<sup>2</sup></i>) time worst case. <br/>

2. If space is not a problem ==> <b><i>Mergesort</i></b><br/>
<i>Why? </i> runs in O(<i>nlog(n)</i>) time <u><b>worst case</b></u>. <br/>
<i>Downsides? </i> Needs linear space additionally. <br/>

3. If problem size is small or input is nearly sorted ==> <b><i>Insertion Sort</i></b><br/>
<i>Why? </i> Smaller constants in insertion sort lead to faster sort. <br/>

4. If input elements are integers whose range is O(n) ==> <b><i>Counting Sort</i></b><br/>
<i>Why? </i> Runs in linear time <br/>
<i>Downsides? </i> Works only for integers <br/>

5. When input is generated by a random process that distributes elements uniformly and independently over the interval [0,1) ==> <b><i>Bucket Sort</i></b><br/>
<i>Why? </i> Runs in linear time on average under above conditions <br/>
